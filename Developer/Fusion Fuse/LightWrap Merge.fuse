   --[[--
Example Fuse - Light Wrap Merge.
This will blend background color into the fringe of the foreground image, using YUV.

Copyright (c) 2018-2020, BMD, by SR
This Fuse Demos built in image processing functions in Fusion.

This Uses Fusion internal Image processing operations:
Blur, Channel Math Operations, Color Space of YUV to copy BG chroma into fringe,  Channel Boolean and Copying,
Merge will overlay one image over another.
These Functions have many options and processing types. See inline comments

--]]--

--******************************************************************************************************
-- This Registers the Fuse into Fusion, gives its Name, and Menu location. Location of Help. Can Fuse be edited.
FuRegisterClass("LightWrapMerge", CT_Tool, {
	REGS_Name = "LightWrapMerge",
	REGS_Category = "Fuses\\Examples",
	REGS_OpIconString = "LWM",
	REGS_OpDescription = "Example, using internal Image Processing functions Merge to Light Wrap",
	REGS_HelpTopic = "Example Location of Help", --This can be a URL
	REGS_URL				= "www.blackmagicdesign.com",
	--REGS_IconID = "Icons.Tools.Icons.Example",-- This can be Inline as an array of Values
	REG_OpNoMask = true,
	REG_NoBlendCtrls = true,
	REG_NoObjMatCtrls = true,
	REG_NoMotionBlurCtrls = true,
	REG_NoBlendCtrls = false,
	REG_Fuse_NoEdit     = false,
	REG_Fuse_NoReload   = false,
	REG_Version = 1, 
}) -- End of RegisterClass
--****************************************************************************************************

--Create will define all the controls, like sliders, check boxes, onscreen crosshairs etc, that will show in Inspector Tool control area
function Create()

	InButton = self:AddInput("Output", "Button", {
			LINKID_DataType = "Number",
			INPID_InputControl = "MultiButtonControl",
			INP_Default = 0,
			{MBTNC_AddButton = "Final", 	MBTNCD_ButtonWidth = 0.2, },
			{MBTNC_AddButton = "Fringe", 	MBTNCD_ButtonWidth = 0.2, },
			{MBTNC_AddButton = "Image", 	MBTNCD_ButtonWidth = 0.2, },
			})


-- Control Nest will define which controls are nested into a group to compact and organizie the Inspector.

self:BeginControlNest("LightWrap", "LightWrapNest", true);



	InBlurBg = self:AddInput("Blur Fringe", "XBlurFg", {
			LINKS_Name = "Blur BG",
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 20.0,
			INP_MinScale = 10.0,
			INP_Default = 10.0,
			})		
	InFringe = self:AddInput("Fringe Size", "Fringe", {
			LINKS_Name = "Fringe Size",
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 1.0,
			INP_MinScale = 0.0,
			INP_Default = 0.4,
			})		
	InChromafrng = self:AddInput("Chroma Blend", "ChromaBlend", {
			LINKS_Name = "Chroma Blend",
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 0.5,
			INP_MinScale = 0.0,
			INP_Default = 0.0,
			})		
	InBlndLuma = self:AddInput("Luma Blend", "LumaBlend", {
			LINKS_Name = "Luma Blend",
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 0.2,
			INP_MinScale = 0.0,
			INP_Default = 0.0,
			})		
	InBloom = self:AddInput("Bloom", "Bloom", {
			LINKS_Name = "Light Mix",
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 0.2,
			INP_MinScale = 0.0,
			INP_Default = 0.0,
			})		

	self:EndControlNest()
--****************************************************************************************************

-- Control Nest will define which controls are nested into a group to compact and organizie the Inspector.
	self:BeginControlNest("Merge", "MergeNest", true);
	
		InCenter = self:AddInput("Center", "Center", {
			LINKID_DataType      = "Point",
			INPID_InputControl   = "OffsetControl",
			INPID_PreviewControl = "CrosshairControl",
			INP_DefaultX         = 0.5,
			INP_DefaultY         = 0.5,
			})

		InSize = self:AddInput("Size", "Size", {
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
			INP_MaxScale = 5.0,
			INP_MinScale = 0.0,
			ICD_Center = 1, 		-- this sets the default value to the center of the slider
			INP_Default = 1.0,
			INP_MinAllowed = 0,
			})

		InAngle = self:AddInput("Angle", "Angle", {
			LINKID_DataType = "Number",
			INPID_InputControl = "ScrewControl",
			INP_MinScale = 0.0,
			INP_MaxScale = 100.0,
			INP_Default = 0,
			})

		InBlend = self:AddInput("Blend", "Blend", {
			LINKID_DataType = "Number",
			INPID_InputControl = "SliderControl",
	--		ICD_Width = 0.5,
			ICS_ControlPage = "Controls",
			INP_Default = 1.0,
			INP_MinAllowed = 0,
			INP_MaxAllowed = 1,
		})
	self:EndControlNest()
--***********************************************

-- Image Inputs are used to get images into the Tool
	InBackground = self:AddInput("Background", "Background", {
		LINKID_DataType = "Image",
		INPID_InputControl = "ImageControl",
		ICS_ControlPage = "Controls",
		LINK_Main = 1,
	})
-- The Foreground Image input
	InForeground = self:AddInput("Foreground", "Foreground", {
		LINKID_DataType = "Image",
		INPID_InputControl = "ImageControl",
		ICS_ControlPage = "Controls",
		LINK_Main = 2,
		INP_Required = false,
	})
-- The output is an Image
	OutImage = self:AddOutput("Output", "Output", {
		LINKID_DataType = "Image",
		LINK_Main = 1,
	})	
end  -- end of Create()

--*************************************************************************************************** *
-- Function to blend Chroma of Foreground image with BG image using fringe
funcUV = 
{
	[1] =	function(x,y,p1,p2) -- UV Blend function.  tmpBG=p2  fg=p1
			p1.R = p1.R 
			p1.G = ((p1.G - 0.5) * blndUVx) + blndUV * (((p1.G - 0.5) * (1.0 - p2.A)) + ((p2.G - 0.5) * p2.A)) + 0.5 -- Chroma U
			p1.B =  ((p1.B - 0.5) * blndUVx) + blndUV * (((p1.B - 0.5) * (1.0 - p2.A)) + ((p2.B - 0.5) * p2.A)) + 0.5 -- Chroma V
			p1.A = p1.A 
			return p1
		end,
	[2] =	function(x,y,p1,p2) --  Luma Blend
			p1.R = (p1.R * (1.0 - lum)) + lum * ((p1.R * (1.0 - p2.A)) + (p2.R * p2.A))  -- Luma
--			p1.G = ((p1.G - 0.5) * blndUVx) + blndUV * (((p1.G - 0.5) * (1.0 - p2.A)) + ((p2.G - 0.5) * p2.A)) + 0.5 -- Chroma U
--			p1.B =  ((p1.B - 0.5) * blndUVx) + blndUV * (((p1.B - 0.5) * (1.0 - p2.A)) + ((p2.B - 0.5) * p2.A)) + 0.5 -- Chroma V
			p1.G = p1.G 
			p1.B = p1.B 
			p1.A = p1.A 
			return p1
		end,
}



--***************************************************************************************************
-- The Process section is the main section where the image processing renders
function Process(req)
	
-- Get Values from the Control panel from the Inspector Tool Controls
	
-- Get Images imputs and create output and temp image like the original.
	local bg = InBackground:GetValue(req)
	local out = bg:Copy() 
	local fg = InForeground:GetValue(req)
	local tmpBG  = bg:Copy() --Image({IMG_Like = bg})
	local tmpfg
	if fg then
		tmpfg  = fg:Copy() 
	else
		tmpfg = bg:Copy() 
		fg = bg
	end
	local tmpfgB  = bg:Copy() 
	local tmpgfgx = tmpfg:Copy() 
	
	
--	Get Blur values 
	local blurBg = InBlurBg:GetValue(req).Value

	
---Do the Blur of Background to TmpBG image ****************
	if blurBg > 0.0  then
		bg:Blur(tmpBG, { -- Blur will blur BG into the result out
			BLUR_Type = 5, --Fast Gausian
			BLUR_Red = 1, --do_r == 1 and true or false,
			BLUR_Green =1, -- do_g == 1 and true or false,
			BLUR_Blue = 1, --do_b == 1 and true or false,
			BLUR_Alpha = 0, --do not_a == 1 and true or false,
			BLUR_XSize = blurBg/360, 
			BLUR_YSize = blurBg/360,
			BLUR_Blend = 1.0,
			BLUR_Normalize = op==1 and glow or 1.0,
			BLUR_Passes = 0.0,
			BLUR_RedScale =1.0,
			BLUR_GreenScale = 1.0,
			BLUR_BlueScale = 1.0,
			BLUR_AlphaScale = 1.0,
			})
	end
--******************************************************

-- Get the values from the Tool controls from the Inspector for the Merge	
	local center = InCenter:GetValue(req) -- This has 2 Outputs X & Y
	local xsize = InSize:GetValue(req).Value
	local ysize = InSize:GetValue(req).Value
	local angle = InAngle:GetValue(req).Value
	local blend = InBlend:GetValue(req).Value
	local fringe = 0.05 * (InFringe:GetValue(req).Value)
	local Chromafrng = (InChromafrng:GetValue(req).Value)
	local Lumafrng = (InBlndLuma:GetValue(req).Value)
	local Bloom = (InBloom:GetValue(req).Value)
	
	
--Make inside fringe from the foreground alpha *****************************************************
	fg:Blur(tmpfg, { 
		BLUR_Type = 2, --Bartlet
		BLUR_Red = false, 
		BLUR_Green =false, 
		BLUR_Blue = false, 
		BLUR_Alpha = true, --Do Alpha blur only
		BLUR_XSize = fringe, 
		BLUR_YSize = fringe, 
		BLUR_Blend = 1.0,
		BLUR_Normalize = 1.0 --op==1 and glow or 1.0,
		})
	--Create Inside Fringe Alpha
	tmpfgx = fg:ChannelOpOf("Threshold", fg, {R = "", G = "", B = "", A = "fg.A"}, 0.2, 0.4)
	tmpfg = tmpfgx:ChannelOpOf("Subtract", tmpfg, {R = "", G = "", B = "", A = "fg.A"})
	tmpfg = tmpfg:ChannelOpOf("Threshold", tmpfg, {R = "", G = "", B = "", A = "fg.A"}, 0.0, 1.0)	-- Limit result to 0-1
--	out = img:ChannelOpOf("Copy", fg, {R = "fg.R", G = "fg.G", B = "fg.B", A = "fg.A"}) -- Copy fg channels to output

--	tmpfg:Gain(1 , 1 , 1, 2)--RGBA
--	fg = fg:ChannelOpOf("Multiply", nil, { R = 1.0, G = 1.0, B = 1.0, A = -1.0}) 
--	fg = fg:ChannelOpOf("Add", nil, { R = 0.0, G = 10.0, B = 0.0, A = 1.0}) 
--	tmpfg = fg:ChannelOpOf("Add", tmpfg, {R = "", G = "", B = "", A = "fg.A"}, 0.0, 1.0)	-- Limit result to 0-1

	tmpfg:Blur(tmpfg, { 
		BLUR_Type = 2, --Bartlet
		BLUR_Red = false, 
		BLUR_Green =false, 
		BLUR_Blue = false, 
		BLUR_Alpha = true, --Do Alpha blur only
		BLUR_XSize = fringe * 0.1, 
		BLUR_YSize = fringe * 0.1, 
		BLUR_Blend = 1.0,
		BLUR_Normalize = 0.5 --op==1 and glow or 1.0,
		})

--*************************************************************************

--Transform Foreground images **************************************
--transform fringe image	
	tmpfg = tmpfg:Transform(nil, { 
		XF_XOffset = center.X, 
		XF_YOffset = center.Y, 
		XF_XAxis = 0.5,
		XF_YAxis = 0.5,
		XF_XSize = xsize, 
		XF_YSize = ysize, 
		XF_Angle = angle, 
		XF_EdgeMode = "Canvas",
		})
--tranform fg
	fg = fg:Transform(nil, { 
		XF_XOffset = center.X, 
		XF_YOffset = center.Y, 
		XF_XAxis = 0.5,
		XF_YAxis = 0.5,
		XF_XSize = xsize, 
		XF_YSize = ysize, 
		XF_Angle = angle, 
		XF_EdgeMode = "Canvas",
		})
	tmpBG = tmpfg:ChannelOpOf("Copy", tmpBG, {R = "fg.R", G = "fg.G", B = "fg.B", A = "bg.A"}) -- Copy Fringe alpha to tmpBG
	tmpBG = tmpBG:ChannelOpOf("Threshold", tmpBG, {R = "", G = "", B = "", A = "bg.A"}, 0.0, 1.0)	-- Limit result to 0-1

--********************************************	

--Use YUV space to blend the UV of the Fringe into FG image ********************
	fg:CSConvert ("RGB", "YUV") -- Convert RGB to YUV where Y is in R, U is in G, V is in B
	tmpBG:CSConvert ("RGB", "YUV") -- Convert RGB to YUV where Y is in R, U is in G, V is in B
	if Chromafrng > 0.0 then
		fg:MultiProcessPixels(nil, {blndUV = Chromafrng , blndUVx = (1.0 - Chromafrng), lum =Lumafrng }, 0,0, bg.Width, bg.Height, fg, tmpBG, funcUV[1])	-- 1 means function UV blend	
	end
	if Lumafrng > 0.0 then
		fg:MultiProcessPixels(nil, {blndUV = Chromafrng , blndUVx = (1.0 - Chromafrng), lum =Lumafrng }, 0,0, bg.Width, bg.Height, fg, tmpBG, funcUV[2])	--2 means function UV + Luma blend	
	end
	fg:CSConvert ( "YUV" , "RGB") -- Convert YUV back to RGB 
--*************************************************************************
	
-- Merge over backround and output ******************************************
	out  = bg:Copy()
	out:OMerge(fg, 0, 0) -- Merge FG over BG

-- Blend Merge Blured BG over composite image ******************************************
	tmpBG:CSConvert ( "YUV" , "RGB") -- Convert YUV back to RGB 
	if Bloom> 0.0 then
--		tmpBG = tmpfg:ChannelOpOf("Copy", tmpBG, {R = "fg.R", G = "fg.G", B = "fg.B", A = "bg.A"}) -- Copy Fringe alpha to tmpBG
		tmpBG = tmpBG:ChannelOpOf("Multiply", tmpBG, {R = "fg.A", G = "fg.A", B = "fg.A", A = ""}) -- Post Multiply alpha in Blured BG
		tmpBG:Gain(Bloom * 1.5, Bloom * 1.5, Bloom * 1.5, Bloom * 0.5) -- Scale the Bloom BG image no linearly to simulate Light from the BG 
		tmpBG = tmpBG:ChannelOpOf("Multiply", fg, {R = "fg.A", G = "fg.A", B = "fg.A", A = ""}) -- Post Multiply alpha in Blured BG
		out:OMerge(tmpBG, 0, 0) --  to merge fringe over blured BG
	else
		tmpBG = tmpBG:ChannelOpOf("Multiply", fg, {R = "fg.A", G = "fg.A", B = "fg.A", A = ""}) -- Post Multiply alpha in Blured BG	
	end	

--	Done with processing. Output image.
	local button = InButton:GetValue(req).Value
	if button ==0 then
		OutImage:Set(req, out)
	elseif button == 1 then
		OutImage:Set(req, tmpBG) -- Color Fg +fringe Alpha
	elseif button == 2 then
		if Bloom> 0.0 then
			fg:OMerge(tmpBG, 0, 0) --  to merge fringe over blured BG
		end
		OutImage:Set(req, fg) --BG in YUV Blured
	end

	
end -- end Process()
